= wav2vec.py

== Introduction

`wav2vec.py` is a Python script and package for converting waveform files (WAV or AIFF) into vector graphics (SVG or PostScript). Use cases include using an audio waveform as an element in a graphic design or including a waveform in a LaTeX document.

== Features

* Portable: runs on Python 2.7+ and Python 3 and does not depend on any third-party packages.
* Supported PCM input file formats:
** 8-bit signed AIFF
** 8-bit unsigned WAV
** 16-bit signed WAV and AIFF
** 32-bit signed WAV and AIFF
* Input file format is automatically detected and handled (the file name/extension is unimportant)
* Output file formats:
** Scalable Vector Graphics (SVG)
** PostScript
** Comma-Separated Values (CSV)
* Easy to write a custom output formatter
* Options to scale the output data
* Can process input files in chunks so large files can be processed with minimal memory

== Install

=== From PyPI with PIP
TODO

=== From git repo

Clone the git repository:

[source, sh]
----
$ git clone https://github.com/cristoper/wav2vec.git
$ cd wav2vec
----

Now you can run `wav2vec.py` directly:

[source, sh]
----
$ python wav2vec.py -h
----

Or install the package with PIP:

[source, sh]
----
$ pip install .
$ wav2vec -h
----

== Usage

Once the package is installed using pip (see above), the command can be invoked as `wav2vec`. It takes an input file and outputs (SVG, by default) to stdout:

[source, sh]
----
$ wav2vec filename.wav > filename.svg
----

Run `wav2vec -h` to get a usage summary:

----
usage: wav2vec [-h] [--format {PostScript,SVG,CSV}] [--width WIDTH]
               [--height HEIGHT] [--stream BS] [--downtoss N]
               [--log {DEBUG,INFO,WARNING,ERROR,CRITICAL}]
               filename

Convert WAV and AIFF files to vector (SVG, PostScript, CVS) graphics.

positional arguments:
  filename              The WAV file to read

optional arguments:
  -h, --help            show this help message and exit
  --format {PostScript,SVG,CSV}, -f {PostScript,SVG,CSV}
                        The output format, one of: SVG, CSV, PostScript.
                        Default is SVG.
  --width WIDTH         Maximum width of generated SVG (graphic will be scaled
                        down to this size in px)
  --height HEIGHT       Maximum height of generated SVG (graphic will be
                        scaled down to this size in px). Note that this scales
                        according to the highest possible amplitude (given the
                        sample bit depth), not the highest amplitude that
                        actually occurs in the data.
  --stream BS           Stream the input file size in chunks (of BS number of
                        frames at a time) and process/format each chunk
                        separately. Useful for conserving memory when
                        processing large files, but note that multi-channel
                        paths will be split up into BS-sized chunks. By
                        default BS=0, which causes the entire file to be read
                        into memory before processing.
  --downtoss N          Downsize by keeping only 1 out of every N samples.
  --log {DEBUG,INFO,WARNING,ERROR,CRITICAL}
                        Set the logging level.

The output is sent to stdout.

----

=== Options
==== Output format

The `--format` flag sets the output format. `wav2vec` includes three formatters: `SVG` (default if no `--format` is given), `PostScript`, and `CVS`.

[source, sh]
----
$ wav2vec filename.wav --format PostScript > output.ps
----

==== Scale output

Use the `--width` and `--height` options to scale the output so that its maximum bounds are equal to or less than the values following the flags. In SVG these values are pixels ("user units"); in PostScript the values are interpreted as pts (1/72 of an inch). By default (if the flags are not given), the width is set to 1000 and the height to 500.

[source, sh]
----
$ wav2vec filename.wav --width 500 --height 350 > output.svg
----

==== Stream input file

By default, `wav2vec` reads the entire input file into memory and then streams the output to stdout as it process it. Passing the `--stream` flag will cause `wav2vec` to process the input file in chunks. This can be useful if the input file is very big and won't fit into available memory. The `--stream` flag requires one argument, the number of frames to read and process at a time (each frame includes one sample from each channel). A value of around 1024 seems to work well.

[source, sh]
----
$ wav2vec filename.aiff --stream 1024 > output.svg
----

Note that using the `--stream` flag on files with multiple channels will result in non-continuous paths in the output (because channel data is interleaved in WAV/AIF files).

Note also that converting very large audio files to SVG may not be practical: most SVG editors will not handle paths with hundreds of thousands or millions of points well.

=== Examples

== Hacking

=== Run tests

=== Write custom formatter

== Support the Author
